USE [handnote_db]
GO

-- =============================================
-- 1. GET USER FRIEND REQUESTS (With Pagination)
-- =============================================
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[sp_GetUserFriendRequests]
    @UserId INT,
    @Page INT = 1,
    @Limit INT = 10
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Variables
    DECLARE @ErrorMessage NVARCHAR(500);
    DECLARE @Offset INT;
    
    BEGIN TRY
        -- Validate input parameters
        IF @UserId IS NULL OR @UserId <= 0
        BEGIN
            SET @ErrorMessage = 'UserId is required and must be a positive integer.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        IF @Page IS NULL OR @Page <= 0
        BEGIN
            SET @Page = 1;
        END
        
        IF @Limit IS NULL OR @Limit <= 0
        BEGIN
            SET @Limit = 10;
        END
        
        IF @Limit > 100
        BEGIN
            SET @Limit = 100; -- Maximum limit to prevent performance issues
        END
        
        -- Calculate offset
        SET @Offset = (@Page - 1) * @Limit;
        
        -- Check if user exists
        IF NOT EXISTS (SELECT 1 FROM [dbo].[users] WHERE [user_id] = @UserId)
        BEGIN
            SET @ErrorMessage = 'User not found with the provided UserId.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Get total count of pending requests
        DECLARE @TotalCount INT;
        SELECT @TotalCount = COUNT(*)
        FROM [dbo].[friendships] f
        WHERE f.status = 'pending' AND f.addressee_id = @UserId;
        
        -- Get pending friend requests with pagination
        SELECT  
            f.requester_id AS RequesterId,
            u.username AS RequesterUsername,
            u.first_name AS RequesterFirstName,
            u.last_name AS RequesterLastName,
            u.profile_photo_url AS RequesterProfilePicture,
            u.email AS RequesterEmail,
            f.created_at AS RequestSentAt,
            f.friendship_id AS FriendshipId,
            @TotalCount AS TotalCount,
            @Page AS CurrentPage,
            @Limit AS PageSize,
            CEILING(CAST(@TotalCount AS FLOAT) / @Limit) AS TotalPages,
            'SUCCESS' AS Status
        FROM [dbo].[friendships] f
        INNER JOIN [dbo].[users] u ON f.requester_id = u.user_id
        WHERE f.status = 'pending'
          AND f.addressee_id = @UserId
        ORDER BY f.created_at DESC
        OFFSET @Offset ROWS
        FETCH NEXT @Limit ROWS ONLY;
        
    END TRY
    BEGIN CATCH
        -- Return error result
        SELECT 
            NULL AS RequesterId,
            NULL AS RequesterUsername,
            NULL AS RequesterFirstName,
            NULL AS RequesterLastName,
            NULL AS RequesterProfilePicture,
            NULL AS RequesterEmail,
            NULL AS RequestSentAt,
            NULL AS FriendshipId,
            0 AS TotalCount,
            @Page AS CurrentPage,
            @Limit AS PageSize,
            0 AS TotalPages,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS ErrorMessage,
            ERROR_NUMBER() AS ErrorNumber;
    END CATCH
END
GO

-- =============================================
-- 2. GET USER FRIENDS (Like Facebook - No Messages)
-- =============================================
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE or Alter PROCEDURE [dbo].[sp_GetUserFriends]
    @UserId INT,
    @Page INT = 1,
    @Limit INT = 10
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Variables
    DECLARE @ErrorMessage NVARCHAR(500);
    DECLARE @Offset INT;
    
    BEGIN TRY
        -- Validate input parameters
        IF @UserId IS NULL OR @UserId <= 0
        BEGIN
            SET @ErrorMessage = 'UserId is required and must be a positive integer.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        IF @Page IS NULL OR @Page <= 0
        BEGIN
            SET @Page = 1;
        END
        
        IF @Limit IS NULL OR @Limit <= 0
        BEGIN
            SET @Limit = 10;
        END
        
        IF @Limit > 100
        BEGIN
            SET @Limit = 100; -- Maximum limit to prevent performance issues
        END
        
        -- Calculate offset
        SET @Offset = (@Page - 1) * @Limit;
        
        -- Check if user exists
        IF NOT EXISTS (SELECT 1 FROM [dbo].[users] WHERE [user_id] = @UserId)
        BEGIN
            SET @ErrorMessage = 'User not found with the provided UserId.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Get total count of friends
        DECLARE @TotalCount INT;
        SELECT @TotalCount = COUNT(*)
        FROM [dbo].[friendships] f
        WHERE f.status = 'accepted'
          AND (f.requester_id = @UserId OR f.addressee_id = @UserId);
        
        -- Get accepted friends with pagination (Facebook style)
        SELECT  
            CASE 
                WHEN f.requester_id = @UserId THEN f.addressee_id
                ELSE f.requester_id
            END AS FriendId,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.username
                ELSE u1.username
            END AS FriendUsername,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.first_name
                ELSE u1.first_name
            END AS FriendFirstName,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.last_name
                ELSE u1.last_name
            END AS FriendLastName,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.profile_photo_url
                ELSE u1.profile_photo_url
            END AS FriendProfilePicture,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.email
                ELSE u1.email
            END AS FriendEmail,
            f.updated_at AS FriendsSince,
            f.friendship_id AS FriendshipId,
            @TotalCount AS TotalCount,
            @Page AS CurrentPage,
            @Limit AS PageSize,
            CEILING(CAST(@TotalCount AS FLOAT) / @Limit) AS TotalPages,
            'SUCCESS' AS Status
        FROM [dbo].[friendships] f
        INNER JOIN [dbo].[users] u1 ON f.requester_id = u1.user_id
        INNER JOIN [dbo].[users] u2 ON f.addressee_id = u2.user_id
        WHERE f.status = 'accepted'
          AND (f.requester_id = @UserId OR f.addressee_id = @UserId)
        ORDER BY f.updated_at DESC
        OFFSET @Offset ROWS
        FETCH NEXT @Limit ROWS ONLY;
        
    END TRY
    BEGIN CATCH
        -- Return error result
        SELECT 
            NULL AS FriendId,
            NULL AS FriendUsername,
            NULL AS FriendFirstName,
            NULL AS FriendLastName,
            NULL AS FriendProfilePicture,
            NULL AS FriendEmail,
            NULL AS FriendsSince,
            NULL AS FriendshipId,
            0 AS TotalCount,
            @Page AS CurrentPage,
            @Limit AS PageSize,
            0 AS TotalPages,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS ErrorMessage,
            ERROR_NUMBER() AS ErrorNumber;
    END CATCH
END
GO

-- =============================================
-- USAGE EXAMPLES:
-- =============================================
/*
-- Get first page of friend requests (10 per page)
EXEC sp_GetUserFriendRequests @UserId = 1;

-- Get second page of friend requests (5 per page)
EXEC sp_GetUserFriendRequests @UserId = 1, @Page = 2, @Limit = 5;

-- Get first page of friends (10 per page)
EXEC sp_GetUserFriends @UserId = 1;

-- Get third page of friends (20 per page)
EXEC sp_GetUserFriends @UserId = 1, @Page = 3, @Limit = 20;
*/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[sp_SearchUserFriends]
    @UserId INT,
    @Filter NVARCHAR(200) = NULL,
    @Page INT = 1,
    @Limit INT = 10
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Variables
    DECLARE @ErrorMessage NVARCHAR(500);
    DECLARE @Offset INT;
    DECLARE @FilterPattern NVARCHAR(202);
    
    BEGIN TRY
        -- Validate input parameters
        IF @UserId IS NULL OR @UserId <= 0
        BEGIN
            SET @ErrorMessage = 'UserId is required and must be a positive integer.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        IF @Page IS NULL OR @Page <= 0
        BEGIN
            SET @Page = 1;
        END
        
        IF @Limit IS NULL OR @Limit <= 0
        BEGIN
            SET @Limit = 10;
        END
        
        IF @Limit > 100
        BEGIN
            SET @Limit = 100; -- Maximum limit to prevent performance issues
        END

        -- Fix filter validation (optional filter)
        IF @Filter IS NOT NULL AND LEN(TRIM(@Filter)) > 0
        BEGIN
            SET @FilterPattern = '%' + TRIM(@Filter) + '%';
        END
        ELSE
        BEGIN
            SET @FilterPattern = NULL; -- No filter applied
        END

        -- Calculate offset
        SET @Offset = (@Page - 1) * @Limit;
        
        -- Check if user exists
        IF NOT EXISTS (SELECT 1 FROM [dbo].[users] WHERE [user_id] = @UserId)
        BEGIN
            SET @ErrorMessage = 'User not found with the provided UserId.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Get total count of friends (fixed logic)
        DECLARE @TotalCount INT;
        SELECT @TotalCount = COUNT(*)
        FROM [dbo].[friendships] f 
        INNER JOIN [dbo].[users] u1 ON f.requester_id = u1.user_id 
        INNER JOIN [dbo].[users] u2 ON f.addressee_id = u2.user_id 
        WHERE f.status = 'accepted'
          AND (f.requester_id = @UserId OR f.addressee_id = @UserId)
          AND (
              @FilterPattern IS NULL OR
              (f.requester_id = @UserId AND (u2.first_name + ' ' + u2.last_name) LIKE @FilterPattern) OR
              (f.addressee_id = @UserId AND (u1.first_name + ' ' + u1.last_name) LIKE @FilterPattern)
          );
        
        -- Get accepted friends with pagination (fixed logic)
        SELECT  
            CASE 
                WHEN f.requester_id = @UserId THEN f.addressee_id
                ELSE f.requester_id
            END AS FriendId,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.username
                ELSE u1.username
            END AS FriendUsername,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.first_name
                ELSE u1.first_name
            END AS FriendFirstName,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.last_name
                ELSE u1.last_name
            END AS FriendLastName,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.profile_photo_url
                ELSE u1.profile_photo_url
            END AS FriendProfilePicture,
            CASE 
                WHEN f.requester_id = @UserId THEN u2.email
                ELSE u1.email
            END AS FriendEmail,
            f.updated_at AS FriendsSince,
            f.friendship_id AS FriendshipId,
            @TotalCount AS TotalCount,
            @Page AS CurrentPage,
            @Limit AS PageSize,
            CEILING(CAST(@TotalCount AS FLOAT) / @Limit) AS TotalPages,
            'SUCCESS' AS Status
        FROM [dbo].[friendships] f 
        INNER JOIN [dbo].[users] u1 ON f.requester_id = u1.user_id 
        INNER JOIN [dbo].[users] u2 ON f.addressee_id = u2.user_id 
        WHERE f.status = 'accepted'
          AND (f.requester_id = @UserId OR f.addressee_id = @UserId)
          AND (
              @FilterPattern IS NULL OR
              (f.requester_id = @UserId AND (u2.first_name + ' ' + u2.last_name) LIKE @FilterPattern) OR
              (f.addressee_id = @UserId AND (u1.first_name + ' ' + u1.last_name) LIKE @FilterPattern)
          )
        ORDER BY 
            -- Smart sorting: exact matches first if filtering
            CASE 
                WHEN @FilterPattern IS NULL THEN 2
                WHEN (f.requester_id = @UserId AND (u2.first_name + ' ' + u2.last_name) = TRIM(@Filter)) OR
                     (f.addressee_id = @UserId AND (u1.first_name + ' ' + u1.last_name) = TRIM(@Filter)) THEN 1
                ELSE 2
            END,
            f.updated_at DESC
        OFFSET @Offset ROWS
        FETCH NEXT @Limit ROWS ONLY;
        
    END TRY
    BEGIN CATCH
        -- Return error result
        SELECT 
            NULL AS FriendId,
            NULL AS FriendUsername,
            NULL AS FriendFirstName,
            NULL AS FriendLastName,
            NULL AS FriendProfilePicture,
            NULL AS FriendEmail,
            NULL AS FriendsSince,
            NULL AS FriendshipId,
            0 AS TotalCount,
            @Page AS CurrentPage,
            @Limit AS PageSize,
            0 AS TotalPages,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS ErrorMessage,
            ERROR_NUMBER() AS ErrorNumber;
    END CATCH
END
GO
USE [handnote_db]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[sp_LogoutUser]
    @Email NVARCHAR(320),
    @SessionID INT 
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Variables
    DECLARE @UserId INT;
    DECLARE @ErrorMessage NVARCHAR(500);
    DECLARE @IsActive BIT;
    DECLARE @SessionExists BIT = 0;
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Validate input parameters
        IF @Email IS NULL OR LEN(TRIM(@Email)) = 0
        BEGIN
            SET @ErrorMessage = 'Email is required and cannot be empty.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        IF @SessionID IS NULL OR @SessionID <= 0
        BEGIN
            SET @ErrorMessage = 'Valid SessionID is required.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Check if session exists and is active
        IF NOT EXISTS(
            SELECT 1 
            FROM [dbo].[user_sessions] s 
            WHERE s.session_id = @SessionID 
              AND (s.IsDeleted = 0 OR s.IsDeleted IS NULL)
              AND s.expires_at > GETUTCDATE()
        )
        BEGIN
            SET @ErrorMessage = 'Invalid or expired session.';
            THROW 50003, @ErrorMessage, 1;
        END
        
        -- Find user by email and validate session ownership
        SELECT 
            @UserId = u.[user_id],
            @IsActive = u.[is_active]
        FROM [dbo].[users] u
        INNER JOIN [dbo].[user_sessions] s ON u.user_id = s.user_id
        WHERE u.[email] = @Email 
          AND s.session_id = @SessionID
          AND (s.IsDeleted = 0 OR s.IsDeleted IS NULL)
          AND s.expires_at > GETUTCDATE();
        
        -- Check if user exists and session belongs to them
        IF @UserId IS NULL
        BEGIN
            SET @ErrorMessage = 'Invalid email or session does not belong to this user.';
            THROW 50004, @ErrorMessage, 1;
        END
        
        -- Check if account is active (optional check - you might want to allow logout even for inactive accounts)
         IF @IsActive = 0
         BEGIN
             SET @ErrorMessage = 'Account is deactivated. Please contact support.';
             THROW 50005, @ErrorMessage, 1;
         END
        
        -- Mark session as deleted (soft delete)
        UPDATE [dbo].[user_sessions] 
        SET updated_at = GETUTCDATE(),
            IsDeleted = 1  -- Mark as deleted instead of 0
        WHERE session_id = @SessionID;
        
        -- Update user's last activity (optional - you might not want to change is_active on logout)
        UPDATE [dbo].[users] 
        SET [last_updated] = GETUTCDATE()
            -- Removed is_active = 0 because logout shouldn't deactivate the account
        WHERE [user_id] = @UserId;
        
        -- Commit transaction
        COMMIT TRANSACTION;
        
        -- Return success result
        SELECT 
            @UserId AS UserId,
            (SELECT username FROM [dbo].[users] WHERE user_id = @UserId) AS UserName,
            @Email AS Email,
            @SessionID AS SessionId,
            'SUCCESS' AS Status,
            'Logout successful.' AS Message;
        
    END TRY
    BEGIN CATCH
        -- Rollback transaction on error
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Return error result
        SELECT 
            NULL AS UserId,
            NULL AS UserName,
            NULL AS Email,
            NULL AS SessionId,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS Message,
            ERROR_NUMBER() AS ErrorNumber;
            
    END CATCH
END
GO

-- =============================================
-- ALTERNATIVE: Logout All User Sessions
-- =============================================
CREATE OR ALTER PROCEDURE [dbo].[sp_LogoutUserAllSessions]
    @Email NVARCHAR(320)
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @UserId INT;
    DECLARE @ErrorMessage NVARCHAR(500);
    DECLARE @SessionsLoggedOut INT = 0;
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Validate email
        IF @Email IS NULL OR LEN(TRIM(@Email)) = 0
        BEGIN
            SET @ErrorMessage = 'Email is required and cannot be empty.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        -- Find user by email
        SELECT @UserId = [user_id]
        FROM [dbo].[users]
        WHERE [email] = @Email;
        
        IF @UserId IS NULL
        BEGIN
            SET @ErrorMessage = 'User not found with the provided email.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Count and logout all active sessions
        SELECT @SessionsLoggedOut = COUNT(*)
        FROM [dbo].[user_sessions]
        WHERE user_id = @UserId 
          AND (IsDeleted = 0 OR IsDeleted IS NULL)
          AND expires_at > GETUTCDATE();
        
        -- Mark all user sessions as deleted
        UPDATE [dbo].[user_sessions]
        SET IsDeleted = 1,
            updated_at = GETUTCDATE()
        WHERE user_id = @UserId 
          AND (IsDeleted = 0 OR IsDeleted IS NULL);
        
        -- Update user's last activity
        UPDATE [dbo].[users] 
        SET [last_updated] = GETUTCDATE()
        WHERE [user_id] = @UserId;
        
        COMMIT TRANSACTION;
        
        -- Return success result
        SELECT 
            @UserId AS UserId,
            (SELECT username FROM [dbo].[users] WHERE user_id = @UserId) AS UserName,
            @Email AS Email,
            @SessionsLoggedOut AS SessionsLoggedOut,
            'SUCCESS' AS Status,
            CASE 
                WHEN @SessionsLoggedOut = 0 THEN 'No active sessions found.'
                WHEN @SessionsLoggedOut = 1 THEN 'Successfully logged out 1 session.'
                ELSE 'Successfully logged out ' + CAST(@SessionsLoggedOut AS NVARCHAR(10)) + ' sessions.'
            END AS Message;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        SELECT 
            NULL AS UserId,
            NULL AS UserName,
            NULL AS Email,
            0 AS SessionsLoggedOut,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS Message,
            ERROR_NUMBER() AS ErrorNumber;
    END CATCH
END
GO

-- =============================================
-- GET ACTIVE SESSIONS ONLY (Simplified Version)
-- =============================================
CREATE OR ALTER PROCEDURE [dbo].[sp_GetUserActiveSessions]
    @UserId INT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @ErrorMessage NVARCHAR(500);
    
    BEGIN TRY
        -- Validate input
        IF @UserId IS NULL OR @UserId <= 0
        BEGIN
            SET @ErrorMessage = 'UserId is required and must be a positive integer.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        -- Check if user exists
        IF NOT EXISTS (SELECT 1 FROM [dbo].[users] WHERE [user_id] = @UserId)
        BEGIN
            SET @ErrorMessage = 'User not found with the provided UserId.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Get only active sessions (simple version)
        SELECT  
            s.session_id AS SessionId,
            s.refresh_token AS RefreshToken,
            s.expires_at AS ExpiresAt,
            s.created_at AS CreatedAt,
            s.updated_at AS UpdatedAt,
            s.provider AS Provider,
            
            -- Time until expiry
            DATEDIFF(MINUTE, GETUTCDATE(), s.expires_at) AS MinutesUntilExpiry,
            DATEDIFF(HOUR, s.created_at, GETUTCDATE()) AS SessionAgeHours,
            
            -- Count of active sessions
            (SELECT COUNT(*) 
             FROM [dbo].[user_sessions] s2 
             WHERE s2.user_id = @UserId 
               AND (s2.IsDeleted = 0 OR s2.IsDeleted IS NULL)
               AND s2.expires_at > GETUTCDATE()
            ) AS TotalActiveSessions,
            
            'SUCCESS' AS Status
            
        FROM [dbo].[user_sessions] s
        WHERE s.user_id = @UserId
          AND (s.IsDeleted = 0 OR s.IsDeleted IS NULL)
          AND s.expires_at > GETUTCDATE()
        ORDER BY s.created_at DESC;
        
    END TRY
    BEGIN CATCH
        SELECT 
            NULL AS SessionId,
            NULL AS RefreshToken,
            NULL AS ExpiresAt,
            NULL AS CreatedAt,
            NULL AS UpdatedAt,
            NULL AS Provider,
            NULL AS MinutesUntilExpiry,
            NULL AS SessionAgeHours,
            0 AS TotalActiveSessions,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS ErrorMessage,
            ERROR_NUMBER() AS ErrorNumber;
    END CATCH
END
GO

          
  USE [handnote_db]
GO

-- =============================================
-- UPDATE USER PRIVACY SETTINGS (Simplified - Assumes settings always exist)
-- =============================================
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[sp_UpdateUserPrivacySettings]
    @UserId INT,
    @DefaultPostAudience VARCHAR(20) = NULL,
    @ProfileVisibility VARCHAR(20) = NULL,
    @FriendListVisibility VARCHAR(20) = NULL,
    @FriendRequestFrom VARCHAR(20) = NULL,
    @MessageFrom VARCHAR(20) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Variables
    DECLARE @ErrorMessage NVARCHAR(500);
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Validate input parameters
        IF @UserId IS NULL OR @UserId <= 0
        BEGIN
            SET @ErrorMessage = 'UserId is required and must be a positive integer.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        -- Check if user exists and has privacy settings (should always exist after registration)
        IF NOT EXISTS (SELECT 1 FROM [dbo].[user_privacy_settings] WHERE [user_id] = @UserId)
        BEGIN
            SET @ErrorMessage = 'User privacy settings not found. Please contact support.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Validate individual privacy settings values (only if provided)
        IF @DefaultPostAudience IS NOT NULL AND @DefaultPostAudience NOT IN ('public', 'friends', 'only_me')
        BEGIN
            SET @ErrorMessage = 'DefaultPostAudience must be one of: public, friends, only_me.';
            THROW 50003, @ErrorMessage, 1;
        END
        
        IF @ProfileVisibility IS NOT NULL AND @ProfileVisibility NOT IN ('public', 'friends', 'only_me')
        BEGIN
            SET @ErrorMessage = 'ProfileVisibility must be one of: public, friends, only_me.';
            THROW 50004, @ErrorMessage, 1;
        END
        
        IF @FriendListVisibility IS NOT NULL AND @FriendListVisibility NOT IN ('public', 'friends', 'only_me')
        BEGIN
            SET @ErrorMessage = 'FriendListVisibility must be one of: public, friends, only_me.';
            THROW 50005, @ErrorMessage, 1;
        END
        
        IF @FriendRequestFrom IS NOT NULL AND @FriendRequestFrom NOT IN ('public', 'friends_of_friends')
        BEGIN
            SET @ErrorMessage = 'FriendRequestFrom must be one of: public, friends_of_friends.';
            THROW 50006, @ErrorMessage, 1;
        END
        
        IF @MessageFrom IS NOT NULL AND @MessageFrom NOT IN ('public', 'friends_of_friends', 'friends')
        BEGIN
            SET @ErrorMessage = 'MessageFrom must be one of: public, friends_of_friends, friends.';
            THROW 50007, @ErrorMessage, 1;
        END
        

        
        -- Validate business logic constraints
        -- Profile consistency check
        IF (@ProfileVisibility = 'only_me' AND (@FriendListVisibility = 'friends' OR @FriendListVisibility = 'public'))
           OR (@ProfileVisibility = 'friends' AND @FriendListVisibility = 'public')
        BEGIN
            SET @ErrorMessage = 'Friend list visibility cannot be more open than profile visibility.';
            THROW 50008, @ErrorMessage, 1;
        END
        
        -- Message privacy logic check
        IF @FriendRequestFrom = 'friends_of_friends' AND @MessageFrom = 'public'
        BEGIN
            SET @ErrorMessage = 'Message visibility cannot be public when friend requests are limited to friends of friends.';
            THROW 50009, @ErrorMessage, 1;
        END
        
        -- Update privacy settings (only update provided fields)
        UPDATE [dbo].[user_privacy_settings]
        SET 
            default_post_audience = @DefaultPostAudience,
            profile_visibility = @ProfileVisibility,
            friend_list_visibility = @FriendListVisibility,
            friend_request_from = @FriendRequestFrom, 
            message_from = @MessageFrom, 
            updated_at = SYSUTCDATETIME()
        WHERE user_id = @UserId;
        
        -- Commit transaction
        COMMIT TRANSACTION;
        
        -- Return success result with updated settings
        SELECT 
            ups.user_id AS UserId,
            ups.default_post_audience AS DefaultPostAudience,
            ups.profile_visibility AS ProfileVisibility,
            ups.friend_list_visibility AS FriendListVisibility,
            ups.friend_request_from AS FriendRequestFrom,
            ups.message_from AS MessageFrom,
            ups.created_at AS CreatedAt,
            ups.updated_at AS UpdatedAt,
            u.username AS Username,
            u.email AS Email,
            'SUCCESS' AS Status,
            'Privacy settings updated successfully.' AS Message
        FROM [dbo].[user_privacy_settings] ups
        INNER JOIN [dbo].[users] u ON ups.user_id = u.user_id
        WHERE ups.user_id = @UserId;
        
    END TRY
    BEGIN CATCH
        -- Rollback transaction on error
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Return error result
        SELECT 
            @UserId AS UserId,
            NULL AS DefaultPostAudience,
            NULL AS ProfileVisibility,
            NULL AS FriendListVisibility,
            NULL AS FriendRequestFrom,
            NULL AS MessageFrom,
            NULL AS CreatedAt,
            NULL AS UpdatedAt,
            NULL AS Username,
            NULL AS Email,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS Message,
            ERROR_NUMBER() AS ErrorNumber;
            
    END CATCH
END
GO



-- =============================================
-- RESET USER PRIVACY SETTINGS TO DEFAULTS
-- =============================================
CREATE OR ALTER PROCEDURE [dbo].[sp_ResetUserPrivacySettings]
    @UserId INT
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @ErrorMessage NVARCHAR(500);
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- Validate input
        IF @UserId IS NULL OR @UserId <= 0
        BEGIN
            SET @ErrorMessage = 'UserId is required and must be a positive integer.';
            THROW 50001, @ErrorMessage, 1;
        END
        
        -- Check if user privacy settings exist
        IF NOT EXISTS (SELECT 1 FROM [dbo].[user_privacy_settings] WHERE [user_id] = @UserId)
        BEGIN
            SET @ErrorMessage = 'User privacy settings not found. Please contact support.';
            THROW 50002, @ErrorMessage, 1;
        END
        
        -- Reset all settings to public (default values)
        UPDATE [dbo].[user_privacy_settings]
        SET 
            default_post_audience = 'public',
            profile_visibility = 'public',
            friend_list_visibility = 'public',
            friend_request_from = 'public',
            message_from = 'public',
            updated_at = SYSUTCDATETIME()
        WHERE user_id = @UserId;
        
        COMMIT TRANSACTION;
        
        -- Return success result with reset settings
        SELECT 
            ups.user_id AS UserId,
            ups.default_post_audience AS DefaultPostAudience,
            ups.profile_visibility AS ProfileVisibility,
            ups.friend_list_visibility AS FriendListVisibility,
            ups.friend_request_from AS FriendRequestFrom,
            ups.message_from AS MessageFrom,
            ups.updated_at AS UpdatedAt,
            u.username AS Username,
            'SUCCESS' AS Status,
            'Privacy settings reset to defaults successfully.' AS Message
        FROM [dbo].[user_privacy_settings] ups
        INNER JOIN [dbo].[users] u ON ups.user_id = u.user_id
        WHERE ups.user_id = @UserId;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        SELECT 
            @UserId AS UserId,
            NULL AS DefaultPostAudience,
            NULL AS ProfileVisibility,
            NULL AS FriendListVisibility,
            NULL AS FriendRequestFrom,
            NULL AS MessageFrom,
            NULL AS UpdatedAt,
            NULL AS Username,
            'ERROR' AS Status,
            ERROR_MESSAGE() AS Message,
            ERROR_NUMBER() AS ErrorNumber;
    END CATCH
END
GO


